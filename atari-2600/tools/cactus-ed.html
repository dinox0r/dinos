<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üåµ CacTus Ed üåµ</title>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      background: #222;
      font-family: sans-serif;
    }

    .editor-container {
      display: flex;
      width: 100%;
    }

    .grid-panel {
      flex: 2.6;
      overflow: auto;
      padding: 10px;
      box-sizing: border-box;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(80, 20px);
      grid-template-rows: repeat(64, 20px);
      gap: 1px;
    }

    .pixel {
      width: 20px;
      height: 20px;
    }

    .pixel.on svg rect {
      fill: #3f3f3e;
    }

    .pixel.m1 {
      cursor: pointer;
      outline: 1px solid #a77;
      background-color: #a77;
    }

    .pixel.grp1 {
      outline: 1px solid #aa7;
      background-color: #aa7;
      cursor: pointer;
    }

    .code-panel {
      flex: 1;
      background: #111;
      color: #ccc;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .code-output {
      flex: 0.7;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    .code-output textarea {
      flex: 1;
      width: 100%;
      resize: none;
      background: #222;
      color: #0f0;
      border: none;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
    }

    .mini-panel {
      flex-shrink: 0;
      height: 200px;
      display: flex;
      flex-direction: column;
      padding: 5px;
      border-top: 1px solid #333;
    }

    .mini-grid {
      display: grid;
      grid-template-columns: repeat(80, var(--pixel-size, 4px));
      grid-template-rows: repeat(64, var(--pixel-size, 4px));
      gap: 0;
    }

    .mini-pixel {
      width: var(--pixel-size, 4px);
      height: var(--pixel-size, 4px);
      background: #d2d2d1;
    }

    .mini-pixel.on {
      background: #3f3f3e !important;
    }

    .mini-pixel.top {
      background: linear-gradient(to bottom, #3f3f3e 50%, #d2d2d1 50%);
    }

    .mini-pixel.bottom {
      background: linear-gradient(to bottom, #d2d2d1 50%, #3f3f3e 50%);
    }

    .pixel svg {
      width: 100%;
      height: 100%;
    }

    .arrow-buttons {
      padding: 5px;
      display: flex;
      justify-content: center;
      gap: 5px;
    }

    .arrow-buttons button {
      width: 32px;
      height: 32px;
      font-size: 16px;
      background: #333;
      color: #ccc;
      border: 1px solid #555;
      cursor: pointer;
    }

    .arrow-buttons button:hover {
      background: #444;
    }

    #resetBtn {
      margin-top: 8px;
      padding: 4px 8px;
      border: 1px solid #ccc;
      background-color: #eee;
      cursor: pointer;
    }

    #resetBtn:hover {
      background-color: #ddd;
    }

    #labelInput {
      display: block;
      margin: 10px 0;
      padding: 4px;
      border: 1px solid #ccc;
      font-family: monospace;
      font-size: 14px;
      text-transform: uppercase;
    }

    .zoom-slider {
      width: 100%;
    }

    .mini-grid-container {
      overflow: auto;
      border: 1px solid #333;
      margin-bottom: 4px;
      flex-shrink: 0;
    }
  </style>
</head>
<body>
  <div class="editor-container">
    <div class="grid-panel">
      <div class="grid" id="pixelGrid"></div>
    </div>
    <div class="code-panel">
      <label for="labelInput">Cactus Label (A-Z, 0-9, _ only):</label>
      <input type="text" id="labelInput" maxlength="32" placeholder="CACTUS_LABEL" pattern="[A-Z0-9_]+" />
      <div class="code-output">
        <h3>Output</h3>
        <textarea readonly id="codeBox">// Sprite code will appear here</textarea>
        <button class="copy-button" onclick="on_copy_code_click()">Copy to Clipboard</button>
        <button id="loadFromCodeBtn">Load from Code</button>
      </div>
      <div class="mini-panel">
        <h4>Preview</h4>
        <input class="zoom-slider" type="range" min="1" max="4" step="0.1" value="1" id="zoomSlider" />
        <div class="mini-grid-container">
          <div class="mini-grid" id="miniGrid"></div>
        </div>
        <div class="arrow-buttons">
          <button id="leftBtn">&#x3C;</button>
          <button id="upBtn">&#x5E;</button>
          <button id="downBtn">&#x76;</button>
          <button id="rightBtn">&#x3E;</button>
        </div>
        <button id="resetBtn">Clear GRP1 and M1</button>
      </div>
    </div>
  </div>

  <!-- Load from Code Modal -->
  <dialog id="loadCodeDialog">
    <form method="dialog" style="display: flex; flex-direction: column; gap: 10px; width: 400px; max-width: 90%;">
      <h3>Load Code</h3>
      <textarea id="loadCodeInput" placeholder="Paste your code here" style="width: 100%; height: 150px; background: #111; color: #0f0; border: none; font-family: monospace; font-size: 12px; resize: none;"></textarea>
      <div style="display: flex; justify-content: flex-end; gap: 8px;">
        <button type="submit" id="loadCodeOkBtn">Ok</button>
        <button type="button" id="loadCodeCancelBtn">Cancel</button>
      </div>
    </form>
  </dialog>

  <script>
    const board = [
      "", "", "", "", "", "", "", "", "", "", "", "", "", //
      "            ________                                                           ", //
      "           _O^OOOOOO_                          OO                              ", //
      "           OO_OOOOOOO                         OOO                              ", //
      "           OOOOOOOOOO                        OOOOO                             ", //
      "           OOOOOOOOOO                       OOOOOOOOOOO                        ", //
      "           OOOOO^^^^^                            OOOOOOOOOOO                   ", //
      "           OOOOO___                               OOOOOOOO                     ", //
      "    _     _OOOO^^^^                               OOOOOOOOO                    ", //
      "    O    _OOOOO                                   OOOOOO                       ", //
      "    O_  _OOOOOO__                                 OOO                          ", //
      "    OO__OOOOOOO^O                                 OO                           ", //
      "    OOOOOOOOOOO ^                                 OO                           ", //
      "    ^OOOOOOOOOO                                   O                            ", //
      "     ^OOOOOOOO^                                                                ", //
      "      ^OOO^OO^                                                                 ", //
      "       O^^ ^O                                                                  ", //
      "____   O_   O   __________________________________________________________     ", //
      "       ^^   O_                                                                 ", //
      "            ^^                                                                 ", //
      "                                                                               ", //
      "", "", "", "", "", "", "", "", "", "", "", "", "" //
    ];
    const grid = document.getElementById('pixelGrid');
    const mini_grid = document.getElementById('miniGrid');
    const rows = board.length;
    const cols = 80;

    const cactus_grp1_x = 23;
    const cactus_grp1_y = 14;
    const cactus_grp1_h = 20;
    const cactus_grp1_w = 8;
    const cactus_m1_x = cactus_grp1_x + 8;
    const cactus_m1_y = cactus_grp1_y;
    const cactus_m1_h = cactus_grp1_h;
    const cactus_m1_w = 16;

    // Globals
    let grp1 = load_from_local_storage('grp1', cactus_grp1_h, cactus_grp1_w);
    let m1 = load_from_local_storage('m1', cactus_m1_h, 2);
    let is_mouse_down = false;
    let mouse_down_processed_pixels = [...Array(cactus_grp1_h)].map(() => Array(cactus_grp1_w).fill(0));

    // ------------------------------------------------------------------------
    // UI
    // ------------------------------------------------------------------------
    function draw_main_grid() {
      // Initial render
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const pixel = document.createElement('div');
          // Use the element id to store the element i,j coordinates
          pixel.id = gen_id(i, j);

          // Preload the pixel content based on the 'board' data
          pixel.classList.add('pixel');
          const bij = board[i] ? board[i][j] : ' ';
          let type = 'off';
          if (bij === '_') 
            type = 'bottom';
          else if (bij === '^') 
            type = 'top';
          else if (bij === 'O') 
            type = 'on';
          pixel.appendChild(create_pixel_svg(type));

          const gi = i - cactus_grp1_y;
          const gj = j - cactus_grp1_x;
          if (0 <= gi && gi < cactus_grp1_h && 0 <= gj && gj < cactus_grp1_w) {
            configure_as_grp1_pixel(pixel, gi, gj);
          }

          const mi = i - cactus_m1_y;
          const mj = j - cactus_m1_x;
          if (0 <= mi && mi < cactus_m1_h && 0 <= mj && mj < cactus_m1_w) {
            configure_as_m1_pixel(pixel, mi, mj);
          }

          grid.appendChild(pixel);
        }
      }
    }

    function create_pixel_svg(type) {
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", "0 0 1 1");

      const top = document.createElementNS(svgNS, "rect");
      top.setAttribute("x", 0);
      top.setAttribute("y", 0);
      top.setAttribute("width", 1);
      top.setAttribute("height", 0.5);

      const bottom = document.createElementNS(svgNS, "rect");
      bottom.setAttribute("x", 0);
      bottom.setAttribute("y", 0.5);
      bottom.setAttribute("width", 1);
      bottom.setAttribute("height", 0.5);

      if (type === 'on') {
        top.setAttribute("fill", "#3f3f3e");
        bottom.setAttribute("fill", "#3f3f3e");
      } else if (type === 'top') {
        top.setAttribute("fill", "#3f3f3e");
        bottom.setAttribute("fill", "#d2d2d1");
      } else if (type === 'bottom') {
        top.setAttribute("fill", "#d2d2d1");
        bottom.setAttribute("fill", "#3f3f3e");
      } else {
        top.setAttribute("fill", "#d2d2d1");
        bottom.setAttribute("fill", "#d2d2d1");
      }

      svg.appendChild(top);
      svg.appendChild(bottom);
      return svg;
    }

    function configure_as_grp1_pixel(pixel, gi, gj) {
      pixel.classList.add('grp1');
      pixel.i = gi;
      pixel.j = gj;
      pixel.addEventListener('mousedown', e => on_grp1_pixel_mouse_down(e, pixel));
      pixel.addEventListener('mouseover', () => on_grp1_pixel_mouse_over(pixel));
    }

    function configure_as_m1_pixel(pixel, mi, mj) {
      pixel.classList.add('m1');
      pixel.i = mi;
      pixel.j = mj;
      pixel.addEventListener('mousedown', e => on_m1_pixel_mouse_down(e, pixel));
      pixel.addEventListener('mouseover', () => on_m1_pixel_mouse_over(pixel));
    }

    function toggle_grp1_pixel(pixel) {
      const ii = pixel.i;
      const jj = pixel.j;
      if (ii === 0 || ii === cactus_grp1_h - 1) return;
      grp1[ii][jj] = !grp1[ii][jj] & 1;
      pixel.classList.toggle('on');
      save_to_local_storage();
    }

    function toggle_m1_pixel(pixel) {
      const ii = pixel.i;
      const jj = pixel.j;
      if (ii === 0 || ii === cactus_m1_h - 1) return;
      const i = ii + cactus_m1_y;
      const j = jj + cactus_m1_x;

      for (let x = 0; x < cactus_m1_w; x++) {
        const pixel = document.getElementById(gen_id(i, cactus_m1_x + x));
        pixel.classList.remove('on');
      }

      if (m1[ii][0] === 4) {
        m1[ii][0] = 0;
      } else {
        m1[ii][0]++;
        m1[ii][1] = jj;
        const size = 1 << (m1[ii][0] - 1);
        for (let x = 0; x < size; x++) {
          const pixel = document.getElementById(gen_id(i, j + x));
          pixel.classList.add('on');
        }
      }

      save_to_local_storage();
    }

    function update_grp1_grid_from_data() {
      for (let i = cactus_grp1_y; i < cactus_grp1_y + cactus_grp1_h; i++) {
        for (let j = cactus_grp1_x; j < cactus_grp1_x + cactus_grp1_w; j++) {
          const pixel = document.getElementById(gen_id(i, j));
          const gi = i - cactus_grp1_y;
          const gj = j - cactus_grp1_x;
          if (grp1[gi][gj])
            pixel.classList.add('on');
          else 
            pixel.classList.remove('on');
        }
      }
    }

    function update_m1_grid_from_data() {
      for (let i = 1; i < cactus_m1_h - 1; i++) {
        const y = i + cactus_m1_y;
        for (let j = 0; j < cactus_m1_w - 1; j++) {
          const pixel = document.getElementById(gen_id(y, cactus_m1_x + j));
          pixel.classList.remove('on');
        }

        if (!m1[i][0]) continue;

        const x = cactus_m1_x + m1[i][1];
        const size = 1 << (m1[i][0] - 1);
        for (let j = 0; j < size; j++) {
          const pixel = document.getElementById(gen_id(y, x + j));
          pixel.classList.add('on');
        }
      }
    }

    function gen_id(i, j) {
      return `p_${i}_${j}`;
    }

    // ------------------------------------------------------------------------
    // UI mini view
    // ------------------------------------------------------------------------
    function update_mini_grid() {
      mini_grid.innerHTML = '';
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const miniPixel = document.createElement('div');
          miniPixel.classList.add('mini-pixel');

          const bij = board[i] ? board[i][j] : ' ';
          if (bij === '_') miniPixel.classList.add('bottom');
          else if (bij === '^') miniPixel.classList.add('top');
          else if (bij === 'O') miniPixel.classList.add('on');

          const ii = i - cactus_grp1_y;
          const jj = j - cactus_grp1_x;
          if (0 <= ii && ii < cactus_grp1_h && 0 <= jj && jj < cactus_grp1_w) {
            if (grp1[ii][jj]) {
              miniPixel.classList.remove('top', 'bottom');
              miniPixel.classList.add('on');
            }
          }

          const mii = i - cactus_m1_y;
          const mjj = j - cactus_m1_x;
          if (0 <= mii && mii < cactus_m1_h && m1[mii][0]) {
            const size = 1 << (m1[mii][0] - 1);
            const offset = m1[mii][1];
            if (mjj >= offset && mjj < offset + size) {
              miniPixel.classList.remove('top', 'bottom');
              miniPixel.classList.add('on');
            }
          }

          mini_grid.appendChild(miniPixel);
        }
      }
    }

    // ------------------------------------------------------------------------
    // UI load from code dialog
    // ------------------------------------------------------------------------
    function configure_load_from_code_dialog() {
      const load_from_code_btn = document.getElementById('loadFromCodeBtn');
      const load_code_dialog = document.getElementById('loadCodeDialog');
      const load_code_input = document.getElementById('loadCodeInput');
      const load_code_ok_btn = document.getElementById('loadCodeOkBtn');
      const load_code_cancel_btn = document.getElementById('loadCodeCancelBtn');

      load_code_ok_btn.addEventListener('click', function() {
        load_code_dialog.close('ok');
      });

      load_from_code_btn.addEventListener('click', function() {
        load_code_input.value = ''; // Clear textarea on open
        load_code_dialog.showModal();
        load_code_input.focus();
      });

      load_code_cancel_btn.addEventListener('click', function() {
        load_code_dialog.close();
      });

      load_code_dialog.addEventListener('close', function() {
        if (load_code_dialog.returnValue === 'cancel' || load_code_dialog.returnValue === '') {
          // dialog was cancelled or closed without submitting
          return;
        }
        const code_text = load_code_input.value;
        load_from_code(code_text);
      });
    }

    // ------------------------------------------------------------------------
    // Local storage persistence
    // ------------------------------------------------------------------------
    function save_to_local_storage() {
      localStorage.setItem('label', document.getElementById('labelInput').value);
      localStorage.setItem('grp1', JSON.stringify(grp1));
      localStorage.setItem('m1', JSON.stringify(m1));
    }

    function load_from_local_storage(key, h, w) {
      const stored = localStorage.getItem(key);
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed) && parsed.length === h && parsed.every(row => Array.isArray(row) && row.length === w)) {
            return parsed;
          }
        } catch (e) {
          console.warn(`Failed to parse localStorage for ${key}`);
        }
      }
      return [...Array(h)].map(() => Array(w).fill(0));
    }

    function reset_to_default() {
      document.getElementById('labelInput').value = 'CACTUS'
      localStorage.removeItem('grp1');
      localStorage.removeItem('m1');
      location.reload();
    }

    // ------------------------------------------------------------------------
    // Code generation code
    // ------------------------------------------------------------------------
    function update_sprite_code() {
      const box = document.getElementById('codeBox');
      box.textContent = gen_grp1_code() + '\n' + gen_m1_code();
    }

    function gen_grp1_code() {
      const cactus_name = document.getElementById('labelInput').value;
      let code = `${cactus_name}_SPRITE:\n`;
      code += '  .ds 1             ;‚èê\n';
      for (let i = cactus_grp1_h - 2; i >= 1; i--) {
        code += '  .byte #%' + grp1[i].join('') + '  ;‚èê ';
        code += grp1[i].map(x => x ? '‚ñà' : ' ').join('') + '\n';
      }
      code += '  .ds 1             ;‚èê\n'
      code += `${cactus_name}_SPRITE_END = *\n`;
      return code;
    }

    function gen_m1_code() {
      const cactus_name = document.getElementById('labelInput').value;
      const preamble = `
; HMxy offset reference (rows: pixels, hex and binary):
;
; LEFT  <-------------------------------------------------------------->  RIGHT
;  -7   -6   -5   -4   -3   -2   -1    0   +1   +2   +3   +4   +5   +6   +7   +8
;  70   60   50   40   30   20   10   00   F0   E0   D0   C0   B0   A0   90   80
;0111 0110 0101 0100 0011 0010 0001 0000 1111 1110 1101 1100 1011 1010 1001 1000
;

${cactus_name}_MISSILE_1_CONF:
;    Enable M1 bit
;               ‚Üì\n`;
      const zero_byte = '  .ds 1             ;‚èê';
      const last_label = `${cactus_name}_MISSILE_1_CONF_END = *\n`;

      let lines = Array();
      // The first two scanlines have special behavior:
      // - The **first scanline** does not enable the missile (to prevent it from 
      //   appearing on unrelated scanlines), but it can still store an `HMM1` offset.
      // - The **second scanline** can start at up to 16px of horizontal offset.
      //
      // Although the first scanline doesn‚Äôt render a missile, its stored `HMM1` value
      // (set via `sta HMM1`) will still apply. Typically, this value is 0.
      //
      // However, if the second scanline needs an offset greater than 8px, the 
      // first scanline can store 8px of that offset. The second scanline can then apply 
      // an additional offset (up to 8px), allowing a combined maximum shift of 16px.
      const second_pos_j = m1[1][1];
      let prev_pos_j = 0;
      if (second_pos_j > 8) {
        // Make use of the HMM1 bits of the first scanline
        lines.push(encode_missile(8, 0, 0));
        prev_pos_j = 8;
      } else {
        lines.push(zero_byte);
      }

      for (let i = 1; i < cactus_m1_h - 1; i++) {
        const target_pos_j = m1[i][1];

        const min_j = prev_pos_j - 7;
        const max_j = prev_pos_j + 8;

        if (min_j <= target_pos_j && target_pos_j <= max_j) {
          lines.push(encode_missile(target_pos_j, prev_pos_j, m1[i][0]));
        } else {
          lines.push('  ERROR');
          lines.push(`  ECHO "INVALID offset for HMM1!!! prev scanline pos (next byte)=${prev_pos_j} and target=${target_pos_j}, diff ${target_pos_j - prev_pos_j}"`);
          break;
        }
        prev_pos_j = target_pos_j;
      }
      lines.push(zero_byte);
      lines.reverse();

      return preamble + lines.join('\n') + '\n' + last_label;
    }

    function encode_missile(pos_j, previous_pos_j, size) {
      const offset = ~(pos_j - previous_pos_j) + 1;
      const hmm1 = (offset & 0xf).toString(2).padStart(4, '0');

      const nusiz1 = Math.max(0, size - 1).toString(2).padStart(2, '0');

      const enam1 = size ? '10' : '00';

      return `  .byte #%${hmm1}${nusiz1}${enam1}  ;|`;
    }

    function isNotEmpty(str) {
      return str.trim().length > 0;
    }

    function isNotCommentLine(line) {
      return !line.trimLeft().startsWith(';');
    }

    function load_from_code(code) {
      console.log('Code to parse:', code);
      const lines = code.split('\n')
        .filter(l => isNotEmpty(l) && isNotCommentLine(l))
        .map(l => l.trim());

      let grp1_label_index = 0;
      let grp1_end_label_index = 0;
      let m1_end_label_index = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].endsWith('_SPRITE:')) {
          const index = lines[i].indexOf('_SPRITE:');
          const sprite_name = lines[i].substring(0, index);
          document.getElementById('labelInput').value = sprite_name;

          grp1_label_index = i;
          break;
        }
      }
      for (let i = grp1_label_index + 1; i < lines.length; i++) {
        if (lines[i].endsWith('_END = *')) {
          grp1_end_label_index = i;
          break;
        }
      }
      for (let i = grp1_end_label_index + 1; i < lines.length; i++) {
        if (lines[i].endsWith('MISSILE_1_CONF_END = *')) {
          m1_end_label_index = i;
          break;
        }
      }

      let grp1_index = 0;
      for (let i = grp1_label_index + 1; i < grp1_end_label_index; i++) {
        const l = lines[i];
        if (l.startsWith('.byte #%')) {
          let binary_byte_str = l.split(' ')[1].substr(2, 8);
          for (let j = 0; j < 8; j++) {
            grp1[grp1_index][j] = binary_byte_str[j] === '0' ? 0 : 1;
          }
        }
        grp1_index++;
      }
      grp1.reverse();
      update_grp1_grid_from_data();

      let m1_index = 0;
      let prev_pos_j = 0;

      const hmove = new Map();
      hmove.set('0111', -7);
      hmove.set('0110', -6);
      hmove.set('0101', -5);
      hmove.set('0100', -4);
      hmove.set('0011', -3);
      hmove.set('0010', -2);
      hmove.set('0001', -1);
      hmove.set('0000', 0);
      hmove.set('1111', 1);
      hmove.set('1110', 2);
      hmove.set('1101', 3);
      hmove.set('1100', 4);
      hmove.set('1011', 5);
      hmove.set('1010', 6);
      hmove.set('1001', 7);
      hmove.set('1000', 8);

      for (let i = m1_end_label_index - 1; i > grp1_end_label_index; i--) {
        const l = lines[i];
        if (l.startsWith('.byte #%')) {
          let binary_byte_str = l.split(' ')[1].substr(2, 8);
          const hmm1 = binary_byte_str.substr(0, 4);
          const nusiz1 = binary_byte_str.substr(4, 2);
          const enam1 = binary_byte_str.substr(6, 2);

          m1[m1_index][0] = enam1 === '00' ? 0 : parseInt(nusiz1, 2) + 1;
          m1[m1_index][1] = hmove.get(hmm1) + prev_pos_j;

          prev_pos_j = m1[m1_index][1];
        }
        m1_index++;
      }
      update_m1_grid_from_data();

      update_sprite_code();
      update_mini_grid();
    }

    // ------------------------------------------------------------------------
    // Event handlers 
    // ------------------------------------------------------------------------
    function on_grp1_pixel_mouse_down(e, pixel) {
      e.preventDefault();
      toggle_grp1_pixel(pixel);

      const i = pixel.i;
      const j = pixel.j;
      mouse_down_processed_pixels[i][j] = 1;

      update_sprite_code();
      update_mini_grid();
    }

    function on_m1_pixel_mouse_down(e, pixel) {
      e.preventDefault();
      toggle_m1_pixel(pixel);
      update_sprite_code();
      update_mini_grid();
    }

    function on_grp1_pixel_mouse_over(pixel) {
      const i = pixel.i;
      const j = pixel.j;
      if (i === 0 || i === cactus_grp1_h - 1) {
        pixel.style.cursor = 'not-allowed';
        return;
      }
      if (is_mouse_down && !mouse_down_processed_pixels[i][j]) {
        toggle_grp1_pixel(pixel);
        mouse_down_processed_pixels[i][j] = 1;
        update_sprite_code();
        update_mini_grid();
      }
    }

    function on_m1_pixel_mouse_over(pixel) {
      const i = pixel.i;
      const j = pixel.j;
      if (i === 0 || i === cactus_m1_h - 1) {
        pixel.style.cursor = 'not-allowed';
        return;
      }
      // The first row (bottom-up) is locked for editing and only supports a fine offset
      // of up to 8px to the right using `HMM1`. This is mostly irrelevant for the user
      // since the row is locked for editing.
      //
      // The second row, however, is fully editable and supports offsets across the full
      // 16px range. If the user clicks at or beyond the 9th pixel in this row, the first
      // row is implicitly given an initial 8px offset. This allows the second row to add
      // an additional offset (up to 8px), achieving a combined shift beyond 8px.
      if (1 < i && i <= cactus_m1_h - 2) {
        // Check that mj is [-7, +8] from the position of the previous 
        // missile
        //
        // Previous in this context means the next scanline, as they 
        // will be drawn from bottom to top
        const prev_missile_j = m1[i + 1][1];
        if (!(prev_missile_j - 7 <= j && j <= prev_missile_j + 8)) {
          pixel.style.cursor = 'not-allowed';
        } else {
          pixel.style.cursor = 'pointer';
        }
      }
    }

    function on_grid_mouse_down() {
      is_mouse_down = true;
    }

    function on_grid_mouse_up() {
      is_mouse_down = false;
      mouse_down_processed_pixels.forEach(row => row.fill(0));
      update_sprite_code();
      update_mini_grid(); // Keep preview in sync
    }

    function on_arrow_up_click() {
      const n = grp1.length - 1;
      let first_grp1_row = grp1[1];
      let first_m1_row = m1[1];
      for (let i = 1; i < n - 1; i++) {
        grp1[i] = grp1[i + 1];
        m1[i] = m1[i + 1];
      }
      grp1[n - 1] = first_grp1_row;
      m1[n - 1] = first_m1_row;
      update_grp1_grid_from_data();
      update_m1_grid_from_data();
      update_sprite_code();
      update_mini_grid();
      save_to_local_storage();
    }

    function on_arrow_down_click() { 
      const n = grp1.length - 1;
      let last_grp1_row = grp1[n - 1];
      let last_m1_row = m1[n - 1];
      for (let i = n - 1; i > 1; i--) {
        grp1[i] = grp1[i - 1];
        m1[i] = m1[i - 1];
      }
      grp1[1] = last_grp1_row;
      m1[1] = last_m1_row;
      update_grp1_grid_from_data();
      update_m1_grid_from_data();
      update_sprite_code();
      update_mini_grid();
      save_to_local_storage();
    }

    function on_arrow_right_click() { 
      const n = grp1.length;
      const m = grp1[0].length;
      for (let i = 0; i < n; i++) {
        if (m1[i][0]) m1[i][1] = Math.min(cactus_m1_w - 1, m1[i][1] + 1);
        const last_row_element = grp1[i][m - 1];
        for (let j = m - 1; j > 0; j--) {
          grp1[i][j] = grp1[i][j - 1];
        }
        grp1[i][0] = last_row_element;
      }
      update_grp1_grid_from_data();
      update_m1_grid_from_data();
      update_sprite_code();
      update_mini_grid();
      save_to_local_storage();
    }

    function on_arrow_left_click() {
      const n = grp1.length;
      const m = grp1[0].length;
      for (let i = 0; i < n; i++) {
        const first_row_element = grp1[i][0];
        if (m1[i][0]) m1[i][1] = Math.max(0, m1[i][1] - 1);
        for (let j = 0; j < m - 1; j++) {
          grp1[i][j] = grp1[i][j + 1];
        }
        grp1[i][m - 1] = first_row_element;
      }
      update_grp1_grid_from_data();
      update_m1_grid_from_data();
      update_sprite_code();
      update_mini_grid();
      save_to_local_storage();
    }

    function on_input_change() {
      document.getElementById('labelInput').value.toUpperCase().replace(/[^A-Z0-9_]/g, '');
      update_sprite_code();
      localStorage.setItem('label', document.getElementById('labelInput').value);
    }

    function on_copy_code_click() {
      const code_box = document.getElementById('codeBox');
      navigator.clipboard.writeText(code_box.value)
        .then(() => console.log('Code copied to clipboard'))
        .catch(err => console.error('Copy failed', err));
    }

    function on_zoom_slider_input() {
      const zoom_slider = document.getElementById('zoomSlider');
      const mini_grid = document.querySelector('.mini-grid');
      const mini_grid_container = document.querySelector('.mini-grid-container');
      const size = 4 * parseFloat(zoom_slider.value); // Base size is 4px
      mini_grid.style.setProperty('--pixel-size', `${size}px`);
    }

    // ------------------------------------------------------------------------
    // Main
    // ------------------------------------------------------------------------
    function main() {
      document.body.addEventListener('mousedown', on_grid_mouse_down);
      document.body.addEventListener('mouseup', on_grid_mouse_up);
      document.getElementById('leftBtn').onclick = on_arrow_left_click;
      document.getElementById('rightBtn').onclick = on_arrow_right_click;
      document.getElementById('upBtn').onclick = on_arrow_up_click;
      document.getElementById('downBtn').onclick = on_arrow_down_click;
      document.getElementById('resetBtn').addEventListener('click', reset_to_default);
      document.getElementById('zoomSlider').addEventListener('input', on_zoom_slider_input);

      const label = document.getElementById('labelInput');
      label.addEventListener('input', on_input_change);
      try {
        const storedLabel = localStorage.getItem('label');
        label.value = storedLabel ? storedLabel : "CACTUS";
      } catch (e) {
        console.warn('Failed to load label', e);
        label.value = 'CACTUS';
      }

      configure_load_from_code_dialog();

      draw_main_grid();
      update_grp1_grid_from_data();
      update_m1_grid_from_data();
      update_sprite_code();
      update_mini_grid();
    }

    main();
  </script>
</body>
</html>
